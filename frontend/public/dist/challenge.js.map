{
  "version": 3,
  "sources": ["../../src/challenge.ts"],
  "sourcesContent": ["export {};\r\n\r\nconst MAPS: HTMLElement[] = [];\r\nconst heroContainer = document.getElementById(\"hero_container\")!;\r\nconst heroImage = document.getElementById(\"heroImg\")! as HTMLImageElement;\r\n\r\nconst errorScoreContainer = document.getElementById(\"error_score\")!;\r\nconst successfulKillsScoreContainer = document.getElementById(\"killed_score\")!;\r\nlet errorScore = 0;\r\nlet successfulKillsScore = 0;\r\n\r\nconst ennemiesOnScreen: Enemy[] = [];\r\n\r\nlet transformed = false;\r\nlet transformationOn = false;\r\n\r\nclass Answer {\r\n  data: string;\r\n  good: boolean;\r\n\r\n  constructor(data: string, good: boolean) {\r\n    this.data = data;\r\n    this.good = good;\r\n  }\r\n}\r\n\r\ntype Topic = {\r\n  title: string;\r\n  good: Answer[];\r\n  bad: Answer[];\r\n};\r\n\r\nclass Enemy {\r\n  element: HTMLElement;\r\n  answer: Answer;\r\n\r\n  constructor(element: HTMLElement, answer: Answer) {\r\n    this.element = element;\r\n    this.answer = answer;\r\n  }\r\n}\r\n\r\nconst CAPITALS = {\r\n  title: \"Capitals of the world\",\r\n  good: [new Answer(\"Paris\", true), new Answer(\"London\", true)],\r\n  bad: [new Answer(\"Chicago\", false), new Answer(\"Monaco\", false)],\r\n};\r\n\r\nlet topics: Topic[] = [CAPITALS];\r\n\r\n//local storage\r\n\r\nconst getNextAnswer = () => {\r\n  const randVal = Math.random() > 0.5;\r\n\r\n  if (randVal) {\r\n    return CAPITALS.good.length\r\n      ? CAPITALS.good.pop()\r\n      : CAPITALS.bad.length\r\n      ? CAPITALS.bad.pop()\r\n      : \"done\";\r\n  } else {\r\n    return CAPITALS.bad.length\r\n      ? CAPITALS.bad.pop()\r\n      : CAPITALS.good.length\r\n      ? CAPITALS.good.pop()\r\n      : \"done\";\r\n  }\r\n};\r\n\r\nconst buildEnemyElement = () => {\r\n  const newOpponentContainer = document.createElement(\"div\");\r\n  newOpponentContainer.classList.add(\"enemy_container\");\r\n  const newEnnemyImg = document.createElement(\"img\") as HTMLImageElement;\r\n  newEnnemyImg.src = \"assets/challenge/characters/enemies/wolf/1.png\";\r\n\r\n  newOpponentContainer.append(newEnnemyImg);\r\n\r\n  document.getElementsByTagName(\"body\")[0].append(newOpponentContainer);\r\n\r\n  return newOpponentContainer;\r\n};\r\n\r\nconst buildEnemy = (answer: Answer) => {\r\n  //construct opponent at a specific point, run it\r\n\r\n  const enemyElement = buildEnemyElement();\r\n\r\n  if (!enemyElement) {\r\n    console.log(\"error\");\r\n    return;\r\n  }\r\n\r\n  document.getElementsByTagName(\"body\")[0].append();\r\n\r\n  const enemy = new Enemy(enemyElement, answer);\r\n\r\n  ennemiesOnScreen.push(enemy);\r\n\r\n  return enemy;\r\n};\r\n\r\nconst buildAndLaunchEnemy = (answer: Answer) => {\r\n  const enemy = buildEnemy(answer);\r\n\r\n  if (!enemy) {\r\n    return;\r\n  }\r\n\r\n  launchOpponent(enemy);\r\n};\r\n\r\nconst triggerOpponentsApparition = () => {\r\n  const newAnswer = getNextAnswer();\r\n\r\n  if (newAnswer && newAnswer !== \"done\") {\r\n    buildAndLaunchEnemy(newAnswer);\r\n  } else {\r\n    console.log(\"we re done\");\r\n  }\r\n};\r\n\r\nlet backgroundSrc = \"assets/challenge/maps/challenge_castle.webp\";\r\n\r\nconst makeId = (length: number) => {\r\n  let result = \"\";\r\n  const characters =\r\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n  const charactersLength = characters.length;\r\n  let counter = 0;\r\n  while (counter < length) {\r\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\r\n    counter += 1;\r\n  }\r\n  return result;\r\n};\r\n\r\nenum ANIMATION_ID {\r\n  attack,\r\n  run,\r\n  walk,\r\n  opponent_run,\r\n  opponent_death,\r\n  camera_left_to_right,\r\n  camera_right_to_left,\r\n  character_left_to_right_move,\r\n  transformation_pre_run,\r\n  transformation_run,\r\n}\r\n\r\nconst ANIMATION_RUNNING_VALUES = {\r\n  [ANIMATION_ID.attack]: 0,\r\n  [ANIMATION_ID.run]: 0,\r\n  [ANIMATION_ID.walk]: 0,\r\n  [ANIMATION_ID.opponent_run]: 0,\r\n  [ANIMATION_ID.opponent_death]: 0,\r\n  [ANIMATION_ID.camera_left_to_right]: 0,\r\n  [ANIMATION_ID.camera_right_to_left]: 0,\r\n  [ANIMATION_ID.character_left_to_right_move]: 0,\r\n  [ANIMATION_ID.transformation_pre_run]: 0,\r\n  [ANIMATION_ID.transformation_run]: 0,\r\n};\r\n\r\nconst THROTTLE_NUMS = {\r\n  [ANIMATION_ID.attack]: 0,\r\n  [ANIMATION_ID.run]: 5,\r\n  [ANIMATION_ID.walk]: 5,\r\n  [ANIMATION_ID.opponent_run]: 5,\r\n  [ANIMATION_ID.opponent_death]: 0,\r\n  [ANIMATION_ID.camera_left_to_right]: 5,\r\n  [ANIMATION_ID.camera_right_to_left]: 5,\r\n  [ANIMATION_ID.character_left_to_right_move]: 5,\r\n  [ANIMATION_ID.transformation_pre_run]: 5,\r\n  [ANIMATION_ID.transformation_run]: 5,\r\n};\r\n\r\nconst createMapBlock = (left: number) => {\r\n  const block = document.createElement(\"div\");\r\n  block.classList.add(\"mapBlock\");\r\n  const backgroundImage = document.createElement(\"img\");\r\n  backgroundImage.src = backgroundSrc;\r\n  block.append(backgroundImage);\r\n  block.style.position = \"fixed\";\r\n  block.style.left = `${left}px`;\r\n\r\n  document.getElementsByTagName(\"body\")[0].append(block);\r\n\r\n  return block;\r\n};\r\n\r\nconst moveCamera = (direction: ANIMATION_ID) => {\r\n  if (\r\n    ANIMATION_RUNNING_VALUES[direction] === 0 ||\r\n    ANIMATION_RUNNING_VALUES[direction] > 1\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  MAPS.forEach(\r\n    (map) =>\r\n      (map.style.left = `${\r\n        map.offsetLeft +\r\n        (direction === ANIMATION_ID.camera_left_to_right ? -1 : 1) * 4\r\n      }px`)\r\n  );\r\n\r\n  requestAnimationFrame(() => moveCamera(direction));\r\n};\r\n\r\nconst updateScores = () => {\r\n  errorScoreContainer.innerHTML = \"Erreurs: \" + errorScore.toString();\r\n  successfulKillsScoreContainer.innerHTML =\r\n    \"Bonnes r\u00E9ponses: \" + successfulKillsScore.toString();\r\n};\r\n\r\nconst launchAnimationAndDeclareItLaunched = (\r\n  characterElement: HTMLImageElement,\r\n  throttleNum: number,\r\n  extension: string,\r\n  spriteBase: string,\r\n  spriteIndex: number,\r\n  max: number,\r\n  min: number,\r\n  loop: boolean,\r\n  animationId: ANIMATION_ID\r\n) => {\r\n  ANIMATION_RUNNING_VALUES[animationId]++;\r\n\r\n  launchCharacterAnimation(\r\n    characterElement,\r\n    throttleNum,\r\n    extension,\r\n    spriteBase,\r\n    spriteIndex,\r\n    max,\r\n    min,\r\n    loop,\r\n    animationId\r\n  );\r\n};\r\n\r\nconst launchCharacterAnimation = (\r\n  characterElement: HTMLImageElement,\r\n  throttleNum: number,\r\n  extension: string,\r\n  spriteBase: string,\r\n  spriteIndex: number,\r\n  max: number,\r\n  min: number,\r\n  loop: boolean,\r\n  animationId: ANIMATION_ID\r\n): any => {\r\n  if (!characterElement) alert(\"no element no more!\");\r\n\r\n  if (\r\n    !ANIMATION_RUNNING_VALUES[animationId] ||\r\n    ANIMATION_RUNNING_VALUES[animationId] > 1\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  if (throttleNum < THROTTLE_NUMS[animationId]) {\r\n    throttleNum++;\r\n    return requestAnimationFrame(() =>\r\n      launchCharacterAnimation(\r\n        characterElement,\r\n        throttleNum,\r\n        extension,\r\n        spriteBase,\r\n        spriteIndex,\r\n        max,\r\n        min,\r\n        loop,\r\n        animationId\r\n      )\r\n    );\r\n  }\r\n\r\n  throttleNum = 0;\r\n\r\n  if (spriteIndex === max) {\r\n    if (loop === false) {\r\n      ANIMATION_RUNNING_VALUES[animationId] = 0;\r\n      return;\r\n    }\r\n\r\n    spriteIndex = min;\r\n  } else {\r\n    spriteIndex++;\r\n  }\r\n\r\n  characterElement.src = `${spriteBase}/${spriteIndex}.${extension}`;\r\n\r\n  requestAnimationFrame(() =>\r\n    launchCharacterAnimation(\r\n      characterElement,\r\n      throttleNum,\r\n      extension,\r\n      spriteBase,\r\n      spriteIndex,\r\n      max,\r\n      min,\r\n      loop,\r\n      animationId\r\n    )\r\n  );\r\n};\r\n\r\nconst initAnimation = (animationId: ANIMATION_ID) => {\r\n  ANIMATION_RUNNING_VALUES[animationId] = 0;\r\n};\r\n\r\nconst launchAttack = () => {\r\n  if (transformed) {\r\n    ANIMATION_RUNNING_VALUES[ANIMATION_ID.transformation_run] = 0;\r\n  } else {\r\n    ANIMATION_RUNNING_VALUES[ANIMATION_ID.run] = 0;\r\n  }\r\n\r\n  launchAnimationAndDeclareItLaunched(\r\n    heroImage,\r\n    0,\r\n    \"png\",\r\n    `assets/challenge/characters/${\r\n      transformed ? \"transformed_hero\" : \"hero\"\r\n    }/attack`,\r\n    1,\r\n    transformed ? 12 : 4,\r\n    1,\r\n    false,\r\n    ANIMATION_ID.attack\r\n  );\r\n\r\n  const enemyCanBeHit = (enemy: Enemy) => {\r\n    return (\r\n      enemy.element.getBoundingClientRect().left >\r\n        heroContainer.getBoundingClientRect().left +\r\n          heroContainer.getBoundingClientRect().width &&\r\n      enemy.element.getBoundingClientRect().left <\r\n        heroContainer.getBoundingClientRect().left +\r\n          heroContainer.getBoundingClientRect().width +\r\n          window.innerWidth * 0.15\r\n    );\r\n  };\r\n\r\n  ennemiesOnScreen.forEach((enemy) => {\r\n    if (!enemyCanBeHit(enemy)) {\r\n      console.log(\"Enemy can't be hit. Opponent left >\");\r\n      console.log(\r\n        enemy.element.getBoundingClientRect().left +\r\n          heroContainer.getBoundingClientRect().width\r\n      );\r\n      console.log(\", hero left > \");\r\n      console.log(heroContainer.getBoundingClientRect().left);\r\n      return;\r\n    }\r\n    setTimeout(() => {\r\n      destroyEnemyAndLaunchNewOne(enemy);\r\n      successfulKillsScore++;\r\n      updateScores();\r\n    }, 400);\r\n  });\r\n\r\n  setTimeout(() => {\r\n    launchAnimationAndDeclareItLaunched(\r\n      heroImage,\r\n      0,\r\n      \"png\",\r\n      `assets/challenge/characters/${\r\n        transformed ? \"transformed_hero\" : \"hero\"\r\n      }/run`,\r\n      1,\r\n      transformed ? 6 : 8,\r\n      1,\r\n      true,\r\n      transformed ? ANIMATION_ID.transformation_run : ANIMATION_ID.run\r\n    );\r\n  }, 200);\r\n};\r\n\r\nconst launchOpponent = (enemy: Enemy) => {\r\n  launchAnimationAndDeclareItLaunched(\r\n    enemy.element.firstChild as HTMLImageElement,\r\n    0,\r\n    \"png\",\r\n    \"assets/challenge/characters/enemies/wolf\",\r\n    1,\r\n    9,\r\n    1,\r\n    true,\r\n    ANIMATION_ID.opponent_run\r\n  );\r\n  moveEnemy(enemy);\r\n};\r\n\r\nconst moveEnemy = (enemy: Enemy) => {\r\n  enemy.element.style.left = `${\r\n    enemy.element.getBoundingClientRect().left - 10\r\n  }px`;\r\n\r\n  requestAnimationFrame(() => moveEnemy(enemy));\r\n};\r\n\r\nconst destroyEnemy = (enemy: Enemy) => {\r\n  const launchExplosion = () => {\r\n    launchAnimationAndDeclareItLaunched(\r\n      enemy.element.firstChild as HTMLImageElement,\r\n      0,\r\n      \"png\",\r\n      \"assets/challenge/explosion\",\r\n      1,\r\n      10,\r\n      1,\r\n      false,\r\n      ANIMATION_ID.opponent_death\r\n    );\r\n  };\r\n\r\n  setTimeout(() => {\r\n    ANIMATION_RUNNING_VALUES[ANIMATION_ID.opponent_run] = 0;\r\n    enemy.element.remove();\r\n    triggerOpponentsApparition();\r\n  }, 300);\r\n\r\n  launchExplosion();\r\n\r\n  ennemiesOnScreen.forEach((enemyOnScreen, index) => {\r\n    if (enemy === enemyOnScreen) {\r\n      ennemiesOnScreen.splice(index, 1);\r\n    }\r\n  });\r\n};\r\n\r\nconst destroyEnemyAndLaunchNewOne = (enemy: Enemy) => {\r\n  destroyEnemy(enemy);\r\n  ANIMATION_RUNNING_VALUES[ANIMATION_ID.opponent_run] = 0;\r\n};\r\n\r\nconst detectCollision = () => {\r\n  ennemiesOnScreen.forEach((enemyOnScreen) => {\r\n    if (\r\n      heroContainer.offsetLeft >\r\n      enemyOnScreen.element.getBoundingClientRect().left\r\n    ) {\r\n      errorScore++;\r\n      updateScores();\r\n\r\n      return;\r\n    }\r\n  });\r\n\r\n  requestAnimationFrame(detectCollision);\r\n};\r\n\r\nconst checkForScreenUpdateFromLeftToRight = (throttleNum: number): any => {\r\n  if (ANIMATION_RUNNING_VALUES[ANIMATION_ID.camera_left_to_right] === 0) {\r\n    return;\r\n  }\r\n\r\n  if (throttleNum < 10) {\r\n    throttleNum++;\r\n    return requestAnimationFrame(() =>\r\n      checkForScreenUpdateFromLeftToRight(throttleNum)\r\n    );\r\n  }\r\n\r\n  throttleNum = 0;\r\n\r\n  //deletion\r\n\r\n  //pick first map block\r\n\r\n  const firstMapDomElement = MAPS[0];\r\n\r\n  if (firstMapDomElement.offsetLeft < -window.innerWidth) {\r\n    firstMapDomElement.remove();\r\n    MAPS.shift();\r\n  }\r\n\r\n  //creation\r\n\r\n  const lastMapDomElement = MAPS[MAPS.length - 1];\r\n\r\n  if (\r\n    lastMapDomElement &&\r\n    lastMapDomElement.offsetLeft <= window.innerWidth / 10\r\n  ) {\r\n    MAPS.push(\r\n      createMapBlock(\r\n        lastMapDomElement.offsetLeft + lastMapDomElement.offsetWidth\r\n      )\r\n    );\r\n  }\r\n\r\n  requestAnimationFrame(() => checkForScreenUpdateFromLeftToRight(throttleNum));\r\n};\r\n\r\nconst checkForScreenUpdateFromRightToLeft = (throttleNum: number): any => {\r\n  if (ANIMATION_RUNNING_VALUES[ANIMATION_ID.camera_right_to_left] === 0) {\r\n    return;\r\n  }\r\n\r\n  if (throttleNum < 10) {\r\n    throttleNum++;\r\n    return requestAnimationFrame(() =>\r\n      checkForScreenUpdateFromRightToLeft(throttleNum)\r\n    );\r\n  }\r\n\r\n  throttleNum = 0;\r\n\r\n  //creation\r\n\r\n  //pick first map block\r\n\r\n  const firstMapDomElement = MAPS[0];\r\n\r\n  if (\r\n    firstMapDomElement &&\r\n    firstMapDomElement.offsetLeft > -window.innerWidth\r\n  ) {\r\n    MAPS.unshift(\r\n      createMapBlock(\r\n        firstMapDomElement.offsetLeft - firstMapDomElement.offsetWidth\r\n      )\r\n    );\r\n  }\r\n\r\n  //deletion\r\n\r\n  const lastMapDomElement = MAPS[MAPS.length - 1];\r\n\r\n  if (lastMapDomElement && lastMapDomElement.offsetLeft > window.innerWidth) {\r\n    lastMapDomElement.remove();\r\n    MAPS.pop();\r\n  }\r\n\r\n  requestAnimationFrame(() => checkForScreenUpdateFromRightToLeft(throttleNum));\r\n};\r\n\r\n//CHALLENGE.TS ENDING\r\n\r\nconst initHero = () => {};\r\n\r\nconst launchCharacterMovement = () => {\r\n  moveCamera(ANIMATION_ID.camera_left_to_right);\r\n  launchAnimationAndDeclareItLaunched(\r\n    heroImage,\r\n    0,\r\n    \"png\",\r\n    \"assets/palace/hero/old_walk\",\r\n    1,\r\n    6,\r\n    1,\r\n    true,\r\n    ANIMATION_ID.walk\r\n  );\r\n};\r\n\r\nconst launchCharacterMovementLeft = () => {\r\n  moveCamera(ANIMATION_ID.camera_right_to_left);\r\n  launchAnimationAndDeclareItLaunched(\r\n    heroImage,\r\n    0,\r\n    \"png\",\r\n    \"assets/palace/hero/walk_left\",\r\n    1,\r\n    6,\r\n    1,\r\n    true,\r\n    ANIMATION_ID.walk\r\n  );\r\n};\r\n\r\nconst launchRun = () => {\r\n  ANIMATION_RUNNING_VALUES[ANIMATION_ID.camera_left_to_right]++;\r\n  moveCamera(ANIMATION_ID.camera_left_to_right);\r\n  launchAnimationAndDeclareItLaunched(\r\n    heroImage,\r\n    0,\r\n    \"png\",\r\n    \"assets/challenge/characters/hero/run\",\r\n    1,\r\n    8,\r\n    1,\r\n    true,\r\n    ANIMATION_ID.run\r\n  );\r\n};\r\n\r\nconst heroInitialTop = heroContainer.getBoundingClientRect().top;\r\n\r\nconst launchFly = (jumpingForward = true) => {\r\n  // Get the hero's current position from the bottom style property\r\n  const currentTop = heroContainer.getBoundingClientRect().top;\r\n\r\n  if (jumpingForward) {\r\n    // Move the hero upwards\r\n    const newTop = currentTop - window.innerHeight * 0.005;\r\n    heroContainer.style.top = `${newTop}px`;\r\n\r\n    // Check if the hero has reached the peak\r\n    if (newTop <= heroInitialTop - window.innerHeight * 0.2) {\r\n      jumpingForward = false;\r\n    }\r\n  } else {\r\n    // Move the hero downwards\r\n    const newTop = currentTop + window.innerHeight * 0.005;\r\n    heroContainer.style.top = `${newTop}px`;\r\n\r\n    // Check if the hero has returned to the initial position\r\n    if (newTop >= heroInitialTop) {\r\n      heroContainer.style.top = `${heroInitialTop}px`;\r\n      //launchRun(); // Restart the run animation\r\n      return;\r\n    }\r\n  }\r\n\r\n  // Continue the animation\r\n  requestAnimationFrame(() => launchFly(jumpingForward));\r\n};\r\ndocument.addEventListener(\"keydown\", (event) => {\r\n  if (event.key === \" \") {\r\n    turnInvisible();\r\n  }\r\n  if (event.key === \"w\") {\r\n    launchAttack();\r\n  }\r\n  if (event.key === \"b\") {\r\n    launchTransformation();\r\n  }\r\n});\r\n\r\nconst checkForOpponentsClearance = () => {\r\n  ennemiesOnScreen.forEach((enemyOnScreen) => {\r\n    if (\r\n      heroContainer.getBoundingClientRect().left +\r\n        heroContainer.getBoundingClientRect().width +\r\n        window.innerWidth * 0.05 >\r\n      enemyOnScreen.element.getBoundingClientRect().left\r\n    ) {\r\n    }\r\n    if (enemyOnScreen.element.getBoundingClientRect().left < 0) {\r\n      destroyEnemyAndLaunchNewOne(enemyOnScreen);\r\n    }\r\n  });\r\n\r\n  requestAnimationFrame(checkForOpponentsClearance);\r\n};\r\n\r\nconst turnInvisible = () => {\r\n  heroContainer.style.opacity = \"0.3\";\r\n\r\n  setTimeout(() => (heroContainer.style.opacity = \"1\"), 2000);\r\n};\r\n\r\nconst launchTransformation = () => {\r\n  ANIMATION_RUNNING_VALUES[ANIMATION_ID.run] = 0;\r\n\r\n  document.getElementById(\"transformation_background\")!.style.display = \"flex\";\r\n\r\n  heroImage.src = \"assets/challenge/characters/hero/walk/walk1.png\";\r\n\r\n  transformed = true;\r\n  transformationOn = true;\r\n\r\n  setTimeout(() => {\r\n    launchAnimationAndDeclareItLaunched(\r\n      heroImage,\r\n      0,\r\n      \"png\",\r\n      \"assets/challenge/characters/transformed_hero/pre_run\",\r\n      1,\r\n      9,\r\n      1,\r\n      true,\r\n      ANIMATION_ID.transformation_pre_run\r\n    );\r\n\r\n    clearAllOponentsAndTimeouts();\r\n    ANIMATION_RUNNING_VALUES[ANIMATION_ID.opponent_run] = 0;\r\n\r\n    setTimeout(() => {\r\n      transformationOn = false;\r\n      triggerOpponentsApparition();\r\n\r\n      document.getElementById(\"transformation_background\")!.style.display =\r\n        \"none\";\r\n\r\n      ANIMATION_RUNNING_VALUES[ANIMATION_ID.transformation_pre_run] = 0;\r\n\r\n      launchAnimationAndDeclareItLaunched(\r\n        heroImage,\r\n        0,\r\n        \"png\",\r\n        \"assets/challenge/characters/transformed_hero/run\",\r\n        1,\r\n        6,\r\n        1,\r\n        true,\r\n        ANIMATION_ID.transformation_run\r\n      );\r\n    }, 2000);\r\n  }, 500);\r\n};\r\n\r\nconst clearAllOponentsAndTimeouts = () => {\r\n  ennemiesOnScreen.forEach((enemy, index) => {\r\n    enemy.element.remove();\r\n    ennemiesOnScreen.splice(index, 1);\r\n  });\r\n};\r\n\r\nwindow.onload = () => {\r\n  MAPS.push(createMapBlock(0));\r\n  MAPS.push(createMapBlock(100));\r\n  launchRun();\r\n  // detectCollision();\r\n  checkForScreenUpdateFromLeftToRight(10);\r\n  checkForOpponentsClearance();\r\n  triggerOpponentsApparition();\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
